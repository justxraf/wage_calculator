{"$message_type":"diagnostic","message":"expected one of `)`, `,`, `.`, `?`, `else`, or an operator, found `payment`","code":null,"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13218,"byte_end":13218,"line_start":439,"line_end":439,"column_start":14,"column_end":14,"is_primary":false,"text":[{"text":"            }","highlight_start":14,"highlight_end":14}],"label":"expected one of `)`, `,`, `.`, `?`, `else`, or an operator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":13232,"byte_end":13239,"line_start":441,"line_end":441,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"            payment","highlight_start":13,"highlight_end":20}],"label":"unexpected token","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"missing `,`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13218,"byte_end":13218,"line_start":439,"line_end":439,"column_start":14,"column_end":14,"is_primary":true,"text":[{"text":"            }","highlight_start":14,"highlight_end":14}],"label":null,"suggested_replacement":",","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: expected one of `)`, `,`, `.`, `?`, `else`, or an operator, found `payment`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:441:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m439\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             }\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m-\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96mexpected one of `)`, `,`, `.`, `?`, `else`, or an operator\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96mhelp: missing `,`\u001b[0m\n\u001b[1m\u001b[96m440\u001b[0m \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m441\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             payment\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munexpected token\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Error` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12862,"byte_end":12867,"line_start":428,"line_end":428,"column_start":132,"column_end":137,"is_primary":true,"text":[{"text":"    fn get_reoccuring_payments(db: &Database, date: NaiveDate, shiftPayment: &ShiftPayment) -> Result<Vec<CustomShiftPaymentType>, Error> {","highlight_start":132,"highlight_end":137}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use crate::db_type::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::error::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::fmt::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::io::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use core::error::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use core::fmt::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use native_db::db_type::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use native_model::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use serde::de::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use serde::de::value::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src\\main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use serde::ser::Error;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m\u001b[97m: cannot find type `Error` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:428:132\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m428\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn get_reoccuring_payments(db: &Database, date: NaiveDate, shiftPayment: &ShiftPayment) -> Result<Vec<CustomShiftPaymentType>, Error> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                                                                                                    \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these items\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use crate::db_type::Error;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use std::error::Error;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use std::fmt::Error;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use std::io::Error;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0mand 7 other candidates\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `target_job_id` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13037,"byte_end":13050,"line_start":432,"line_end":432,"column_start":13,"column_end":26,"is_primary":true,"text":[{"text":"        .is(target_job_id)?","highlight_start":13,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `target_job_id` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:432:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m432\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         .is(target_job_id)?\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `payment` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13232,"byte_end":13239,"line_start":441,"line_end":441,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"            payment","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a local variable with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13232,"byte_end":13239,"line_start":441,"line_end":441,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"            payment","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"payments","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m\u001b[97m: cannot find value `payment` in this scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:441:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m441\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             payment\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a local variable with a similar name exists: `payments`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary parentheses around `if` condition","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":2128,"byte_end":2129,"line_start":63,"line_end":63,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    if(schedule.is_empty()) {","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":2148,"byte_end":2149,"line_start":63,"line_end":63,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"    if(schedule.is_empty()) {","highlight_start":27,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":2128,"byte_end":2129,"line_start":63,"line_end":63,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"    if(schedule.is_empty()) {","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\main.rs","byte_start":2148,"byte_end":2149,"line_start":63,"line_end":63,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"    if(schedule.is_empty()) {","highlight_start":27,"highlight_end":28}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unnecessary parentheses around `if` condition\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:63:7\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m63\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     if(schedule.is_empty()) {\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[93m^\u001b[0m                   \u001b[1m\u001b[93m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: remove these parentheses\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m63\u001b[0m \u001b[91m- \u001b[0m    if\u001b[91m(\u001b[0mschedule.is_empty()\u001b[91m)\u001b[0m {\n\u001b[1m\u001b[96m63\u001b[0m \u001b[92m+ \u001b[0m    if\u001b[92m \u001b[0mschedule.is_empty()\u001b[92m \u001b[0m {\n   \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `CustomShiftPaymentType: native_model::Model` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12045,"byte_end":12067,"line_start":395,"line_end":395,"column_start":8,"column_end":30,"is_primary":true,"text":[{"text":"struct CustomShiftPaymentType {","highlight_start":8,"highlight_end":30}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `native_model::Model` is not implemented for `CustomShiftPaymentType`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":12038,"byte_end":12067,"line_start":395,"line_end":395,"column_start":1,"column_end":30,"is_primary":true,"text":[{"text":"struct CustomShiftPaymentType {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"trait impl with same name found","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":11922,"byte_end":11958,"line_start":392,"line_end":392,"column_start":1,"column_end":37,"is_primary":true,"text":[{"text":"#[native_model(id = 2, version = 1)]","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11922,"byte_end":11958,"line_start":392,"line_end":392,"column_start":1,"column_end":37,"is_primary":false,"text":[{"text":"#[native_model(id = 2, version = 1)]","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[native_model]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model_macro-0.6.2\\src\\lib.rs","byte_start":3687,"byte_end":3760,"line_start":101,"line_end":101,"column_start":1,"column_end":74,"is_primary":false,"text":[{"text":"pub fn native_model(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `native_model` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"there are multiple different versions of crate `native_model` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.4.20\\src\\lib.rs","byte_start":4762,"byte_end":4784,"line_start":133,"line_end":133,"column_start":1,"column_end":23,"is_primary":true,"text":[{"text":"pub trait Model: Sized {","highlight_start":1,"highlight_end":23}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":156,"byte_end":165,"line_start":4,"line_end":4,"column_start":5,"column_end":14,"is_primary":false,"text":[{"text":"use native_db::*;","highlight_start":5,"highlight_end":14}],"label":"one version of crate `native_model` used here, as a dependency of crate `native_db`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":174,"byte_end":186,"line_start":5,"line_end":5,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"use native_model::{native_model, Model};","highlight_start":5,"highlight_end":17}],"label":"one version of crate `native_model` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":12038,"byte_end":12067,"line_start":395,"line_end":395,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"struct CustomShiftPaymentType {","highlight_start":1,"highlight_end":30}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.6.2\\src\\codec\\mod.rs","byte_start":904,"byte_end":923,"line_start":28,"line_end":28,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub trait Encode<T> {","highlight_start":1,"highlight_end":20}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ToInput`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\db_type\\to_input.rs","byte_start":110,"byte_end":129,"line_start":5,"line_end":5,"column_start":28,"column_end":47,"is_primary":true,"text":[{"text":"pub trait ToInput: Sized + native_model::Model {","highlight_start":28,"highlight_end":47}],"label":"required by this bound in `ToInput`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`ToInput` is a \"sealed trait\", because to implement it you also need to implement `native_model::Model`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `CustomShiftPaymentType: native_model::Model` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:395:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m395\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct CustomShiftPaymentType {\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `native_model::Model` is not implemented for `CustomShiftPaymentType`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:395:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m395\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct CustomShiftPaymentType {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: trait impl with same name found\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:392:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m392\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[native_model(id = 2, version = 1)]\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: perhaps two different versions of crate `native_model` are being used?\n\u001b[1m\u001b[92mnote\u001b[0m: there are \u001b[1m\u001b[35mmultiple different versions\u001b[0m of crate `\u001b[1m\u001b[35mnative_model\u001b[0m` in the dependency graph\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.4.20\\src\\lib.rs:133:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m133\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Model: Sized {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the required trait\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0msrc\\main.rs:4:5\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use native_db::*;\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m---------\u001b[0m \u001b[1m\u001b[96mone version of crate `native_model` used here, as a dependency of crate `native_db`\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use native_model::{native_model, Model};\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mone version of crate `native_model` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m395\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct CustomShiftPaymentType {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-----------------------------\u001b[0m \u001b[1m\u001b[96mthis type doesn't implement the required trait\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.6.2\\src\\codec\\mod.rs:28:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m28\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Encode<T> {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-------------------\u001b[0m \u001b[1m\u001b[96mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: you can use `\u001b[1m\u001b[35mcargo tree\u001b[0m` to explore your dependency tree\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `ToInput`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\db_type\\to_input.rs:5:28\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait ToInput: Sized + native_model::Model {\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `ToInput`\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `ToInput` is a \"sealed trait\", because to implement it you also need to implement `native_model::Model`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the attribute macro `native_model` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"conflicting implementations of trait `Debug` for type `CustomShiftPaymentType`","code":{"code":"E0119","explanation":"There are conflicting trait implementations for the same type.\n\nErroneous code example:\n\n```compile_fail,E0119\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo {\n    value: usize\n}\n\nimpl MyTrait for Foo { // error: conflicting implementations of trait\n                       //        `MyTrait` for type `Foo`\n    fn get(&self) -> usize { self.value }\n}\n```\n\nWhen looking for the implementation for the trait, the compiler finds\nboth the `impl<T> MyTrait for T` where T is all types and the `impl\nMyTrait for Foo`. Since a trait cannot be implemented multiple times,\nthis is an error. So, when you write:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nThis makes the trait implemented on all types in the scope. So if you\ntry to implement it on another one after that, the implementations will\nconflict. Example:\n\n```\ntrait MyTrait {\n    fn get(&self) -> usize;\n}\n\nimpl<T> MyTrait for T {\n    fn get(&self) -> usize { 0 }\n}\n\nstruct Foo;\n\nfn main() {\n    let f = Foo;\n\n    f.get(); // the trait is implemented so we can use it\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11992,"byte_end":11997,"line_start":393,"line_end":393,"column_start":34,"column_end":39,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":34,"highlight_end":39}],"label":"first implementation here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11992,"byte_end":11997,"line_start":393,"line_end":393,"column_start":34,"column_end":39,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":34,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"C:\\Users\\justx\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\fmt\\mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":12017,"byte_end":12022,"line_start":393,"line_end":393,"column_start":59,"column_end":64,"is_primary":true,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":59,"highlight_end":64}],"label":"conflicting implementation for `CustomShiftPaymentType`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":12017,"byte_end":12022,"line_start":393,"line_end":393,"column_start":59,"column_end":64,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":59,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"C:\\Users\\justx\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\fmt\\mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0119]\u001b[0m\u001b[1m\u001b[97m: conflicting implementations of trait `Debug` for type `CustomShiftPaymentType`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:393:59\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m-----\u001b[0m                    \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mconflicting implementation for `CustomShiftPaymentType`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96mfirst implementation here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `CustomShiftPaymentType: native_model::Model` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12025,"byte_end":12037,"line_start":394,"line_end":394,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[native_db]","highlight_start":1,"highlight_end":13}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":12025,"byte_end":12037,"line_start":394,"line_end":394,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[native_db]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[native_db]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db_macro-0.8.2\\src\\lib.rs","byte_start":211,"byte_end":281,"line_start":14,"line_end":14,"column_start":1,"column_end":71,"is_primary":false,"text":[{"text":"pub fn native_db(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `native_model::Model` is not implemented for `CustomShiftPaymentType`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":12038,"byte_end":12067,"line_start":395,"line_end":395,"column_start":1,"column_end":30,"is_primary":true,"text":[{"text":"struct CustomShiftPaymentType {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"trait impl with same name found","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":11922,"byte_end":11958,"line_start":392,"line_end":392,"column_start":1,"column_end":37,"is_primary":true,"text":[{"text":"#[native_model(id = 2, version = 1)]","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11922,"byte_end":11958,"line_start":392,"line_end":392,"column_start":1,"column_end":37,"is_primary":false,"text":[{"text":"#[native_model(id = 2, version = 1)]","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[native_model]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model_macro-0.6.2\\src\\lib.rs","byte_start":3687,"byte_end":3760,"line_start":101,"line_end":101,"column_start":1,"column_end":74,"is_primary":false,"text":[{"text":"pub fn native_model(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `native_model` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"there are multiple different versions of crate `native_model` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.4.20\\src\\lib.rs","byte_start":4762,"byte_end":4784,"line_start":133,"line_end":133,"column_start":1,"column_end":23,"is_primary":true,"text":[{"text":"pub trait Model: Sized {","highlight_start":1,"highlight_end":23}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":156,"byte_end":165,"line_start":4,"line_end":4,"column_start":5,"column_end":14,"is_primary":false,"text":[{"text":"use native_db::*;","highlight_start":5,"highlight_end":14}],"label":"one version of crate `native_model` used here, as a dependency of crate `native_db`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":174,"byte_end":186,"line_start":5,"line_end":5,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"use native_model::{native_model, Model};","highlight_start":5,"highlight_end":17}],"label":"one version of crate `native_model` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":12038,"byte_end":12067,"line_start":395,"line_end":395,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"struct CustomShiftPaymentType {","highlight_start":1,"highlight_end":30}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.6.2\\src\\codec\\mod.rs","byte_start":904,"byte_end":923,"line_start":28,"line_end":28,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub trait Encode<T> {","highlight_start":1,"highlight_end":20}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `bincode_encode_to_vec`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\serialization.rs","byte_start":7,"byte_end":28,"line_start":1,"line_end":1,"column_start":8,"column_end":29,"is_primary":false,"text":[{"text":"pub fn bincode_encode_to_vec<T>(value: &T) -> crate::db_type::Result<Vec<u8>>","highlight_start":8,"highlight_end":29}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\serialization.rs","byte_start":110,"byte_end":129,"line_start":3,"line_end":3,"column_start":27,"column_end":46,"is_primary":true,"text":[{"text":"    T: serde::Serialize + native_model::Model,","highlight_start":27,"highlight_end":46}],"label":"required by this bound in `bincode_encode_to_vec`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `CustomShiftPaymentType: native_model::Model` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:394:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m394\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[native_db]\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `native_model::Model` is not implemented for `CustomShiftPaymentType`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:395:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m395\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct CustomShiftPaymentType {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: trait impl with same name found\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:392:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m392\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[native_model(id = 2, version = 1)]\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: perhaps two different versions of crate `native_model` are being used?\n\u001b[1m\u001b[92mnote\u001b[0m: there are \u001b[1m\u001b[35mmultiple different versions\u001b[0m of crate `\u001b[1m\u001b[35mnative_model\u001b[0m` in the dependency graph\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.4.20\\src\\lib.rs:133:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m133\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Model: Sized {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the required trait\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0msrc\\main.rs:4:5\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use native_db::*;\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m---------\u001b[0m \u001b[1m\u001b[96mone version of crate `native_model` used here, as a dependency of crate `native_db`\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use native_model::{native_model, Model};\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mone version of crate `native_model` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m395\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct CustomShiftPaymentType {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-----------------------------\u001b[0m \u001b[1m\u001b[96mthis type doesn't implement the required trait\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.6.2\\src\\codec\\mod.rs:28:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m28\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Encode<T> {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-------------------\u001b[0m \u001b[1m\u001b[96mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: you can use `\u001b[1m\u001b[35mcargo tree\u001b[0m` to explore your dependency tree\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `bincode_encode_to_vec`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\serialization.rs:3:27\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn bincode_encode_to_vec<T>(value: &T) -> crate::db_type::Result<Vec<u8>>\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m---------------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n  \u001b[1m\u001b[96m2\u001b[0m \u001b[1m\u001b[96m|\u001b[0m where\n  \u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: serde::Serialize + native_model::Model,\n    \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `bincode_encode_to_vec`\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the attribute macro `native_db` which comes from the expansion of the attribute macro `native_model` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `CustomShiftPaymentType: native_model::Model` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12025,"byte_end":12037,"line_start":394,"line_end":394,"column_start":1,"column_end":13,"is_primary":true,"text":[{"text":"#[native_db]","highlight_start":1,"highlight_end":13}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":12025,"byte_end":12037,"line_start":394,"line_end":394,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[native_db]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[native_db]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db_macro-0.8.2\\src\\lib.rs","byte_start":211,"byte_end":281,"line_start":14,"line_end":14,"column_start":1,"column_end":71,"is_primary":false,"text":[{"text":"pub fn native_db(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `native_model::Model` is not implemented for `CustomShiftPaymentType`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":12038,"byte_end":12067,"line_start":395,"line_end":395,"column_start":1,"column_end":30,"is_primary":true,"text":[{"text":"struct CustomShiftPaymentType {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"trait impl with same name found","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":11922,"byte_end":11958,"line_start":392,"line_end":392,"column_start":1,"column_end":37,"is_primary":true,"text":[{"text":"#[native_model(id = 2, version = 1)]","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11922,"byte_end":11958,"line_start":392,"line_end":392,"column_start":1,"column_end":37,"is_primary":false,"text":[{"text":"#[native_model(id = 2, version = 1)]","highlight_start":1,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[native_model]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model_macro-0.6.2\\src\\lib.rs","byte_start":3687,"byte_end":3760,"line_start":101,"line_end":101,"column_start":1,"column_end":74,"is_primary":false,"text":[{"text":"pub fn native_model(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `native_model` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"there are multiple different versions of crate `native_model` in the dependency graph","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.4.20\\src\\lib.rs","byte_start":4762,"byte_end":4784,"line_start":133,"line_end":133,"column_start":1,"column_end":23,"is_primary":true,"text":[{"text":"pub trait Model: Sized {","highlight_start":1,"highlight_end":23}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":156,"byte_end":165,"line_start":4,"line_end":4,"column_start":5,"column_end":14,"is_primary":false,"text":[{"text":"use native_db::*;","highlight_start":5,"highlight_end":14}],"label":"one version of crate `native_model` used here, as a dependency of crate `native_db`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":174,"byte_end":186,"line_start":5,"line_end":5,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"use native_model::{native_model, Model};","highlight_start":5,"highlight_end":17}],"label":"one version of crate `native_model` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":12038,"byte_end":12067,"line_start":395,"line_end":395,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"struct CustomShiftPaymentType {","highlight_start":1,"highlight_end":30}],"label":"this type doesn't implement the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.6.2\\src\\codec\\mod.rs","byte_start":904,"byte_end":923,"line_start":28,"line_end":28,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub trait Encode<T> {","highlight_start":1,"highlight_end":20}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `bincode_decode_from_slice`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\serialization.rs","byte_start":197,"byte_end":222,"line_start":8,"line_end":8,"column_start":8,"column_end":33,"is_primary":false,"text":[{"text":"pub fn bincode_decode_from_slice<T>(slice: &[u8]) -> crate::db_type::Result<(T, usize)>","highlight_start":8,"highlight_end":33}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\serialization.rs","byte_start":321,"byte_end":340,"line_start":10,"line_end":10,"column_start":38,"column_end":57,"is_primary":true,"text":[{"text":"    T: serde::de::DeserializeOwned + native_model::Model,","highlight_start":38,"highlight_end":57}],"label":"required by this bound in `bincode_decode_from_slice`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `CustomShiftPaymentType: native_model::Model` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:394:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m394\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[native_db]\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `native_model::Model` is not implemented for `CustomShiftPaymentType`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:395:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m395\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct CustomShiftPaymentType {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: trait impl with same name found\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:392:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m392\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[native_model(id = 2, version = 1)]\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: perhaps two different versions of crate `native_model` are being used?\n\u001b[1m\u001b[92mnote\u001b[0m: there are \u001b[1m\u001b[35mmultiple different versions\u001b[0m of crate `\u001b[1m\u001b[35mnative_model\u001b[0m` in the dependency graph\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.4.20\\src\\lib.rs:133:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m133\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Model: Sized {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mthis is the required trait\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0msrc\\main.rs:4:5\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use native_db::*;\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m---------\u001b[0m \u001b[1m\u001b[96mone version of crate `native_model` used here, as a dependency of crate `native_db`\u001b[0m\n  \u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use native_model::{native_model, Model};\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mone version of crate `native_model` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m395\u001b[0m \u001b[1m\u001b[96m|\u001b[0m struct CustomShiftPaymentType {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-----------------------------\u001b[0m \u001b[1m\u001b[96mthis type doesn't implement the required trait\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_model-0.6.2\\src\\codec\\mod.rs:28:1\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m28\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Encode<T> {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m-------------------\u001b[0m \u001b[1m\u001b[96mthis is the found trait\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: you can use `\u001b[1m\u001b[35mcargo tree\u001b[0m` to explore your dependency tree\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `bincode_decode_from_slice`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\serialization.rs:10:38\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn bincode_decode_from_slice<T>(slice: &[u8]) -> crate::db_type::Result<(T, usize)>\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m-------------------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n  \u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m|\u001b[0m where\n \u001b[1m\u001b[96m10\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: serde::de::DeserializeOwned + native_model::Model,\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `bincode_decode_from_slice`\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the attribute macro `native_db` which comes from the expansion of the attribute macro `native_model` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `NaiveDate: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11968,"byte_end":11977,"line_start":393,"line_end":393,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":10,"highlight_end":19}],"label":"the trait `Serialize` is not implemented for `NaiveDate`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11968,"byte_end":11977,"line_start":393,"line_end":393,"column_start":10,"column_end":19,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":10,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":12213,"byte_end":12216,"line_start":405,"line_end":405,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    day: Option<NaiveDate>,","highlight_start":5,"highlight_end":8}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `NaiveDate` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 127 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<NaiveDate>` to implement `Serialize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `NaiveDate: serde::Serialize` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:393:10\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n     \u001b[1m\u001b[96m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Serialize` is not implemented for `NaiveDate`\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n \u001b[1m\u001b[96m405\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     day: Option<NaiveDate>,\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Serialize)]` to your `NaiveDate` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Serialize`:\n               &'a T\n               &'a mut T\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n               (T0, T1, T2, T3, T4)\n             and 127 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<NaiveDate>` to implement `Serialize`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `_::_serde::ser::SerializeStruct::serialize_field`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs:1917:21\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1915\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m---------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1916\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1917\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         T: ?Sized + Serialize;\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SerializeStruct::serialize_field`\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `CustomShiftPaymentReoccurement: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11968,"byte_end":11977,"line_start":393,"line_end":393,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":10,"highlight_end":19}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11968,"byte_end":11977,"line_start":393,"line_end":393,"column_start":10,"column_end":19,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":10,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\main.rs","byte_start":12390,"byte_end":12402,"line_start":410,"line_end":410,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    reoccurement: Option<CustomShiftPaymentReoccurement>,","highlight_start":5,"highlight_end":17}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Serialize` is not implemented for `CustomShiftPaymentReoccurement`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13477,"line_start":451,"line_end":451,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `CustomShiftPaymentReoccurement` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 127 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Serialize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `CustomShiftPaymentReoccurement: serde::Serialize` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:393:10\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n     \u001b[1m\u001b[96m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n \u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     reoccurement: Option<CustomShiftPaymentReoccurement>,\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Serialize` is not implemented for `CustomShiftPaymentReoccurement`\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:451:1\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m enum CustomShiftPaymentReoccurement {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Serialize)]` to your `CustomShiftPaymentReoccurement` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Serialize`:\n               &'a T\n               &'a mut T\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n               (T0, T1, T2, T3, T4)\n             and 127 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Serialize`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `_::_serde::ser::SerializeStruct::serialize_field`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\ser\\mod.rs:1917:21\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1915\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m---------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1916\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1917\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         T: ?Sized + Serialize;\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SerializeStruct::serialize_field`\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `NaiveDate: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12218,"byte_end":12235,"line_start":405,"line_end":405,"column_start":10,"column_end":27,"is_primary":true,"text":[{"text":"    day: Option<NaiveDate>,","highlight_start":10,"highlight_end":27}],"label":"the trait `Deserialize<'_>` is not implemented for `NaiveDate`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `NaiveDate` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 140 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<NaiveDate>` to implement `Deserialize<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `NaiveDate: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:405:10\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m405\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     day: Option<NaiveDate>,\n     \u001b[1m\u001b[96m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `NaiveDate`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `NaiveDate` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a Path\n               &'a [u8]\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n             and 140 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<NaiveDate>` to implement `Deserialize<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_element`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs:1771:12\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1769\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1770\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1771\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         T: Deserialize<'de>,\n     \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SeqAccess::next_element`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `CustomShiftPaymentReoccurement: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12404,"byte_end":12442,"line_start":410,"line_end":410,"column_start":19,"column_end":57,"is_primary":true,"text":[{"text":"    reoccurement: Option<CustomShiftPaymentReoccurement>,","highlight_start":19,"highlight_end":57}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Deserialize<'_>` is not implemented for `CustomShiftPaymentReoccurement`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13477,"line_start":451,"line_end":451,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `CustomShiftPaymentReoccurement` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 140 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Deserialize<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `CustomShiftPaymentReoccurement: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:410:19\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     reoccurement: Option<CustomShiftPaymentReoccurement>,\n     \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Deserialize<'_>` is not implemented for `CustomShiftPaymentReoccurement`\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:451:1\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m enum CustomShiftPaymentReoccurement {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `CustomShiftPaymentReoccurement` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a Path\n               &'a [u8]\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n             and 140 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Deserialize<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_element`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs:1771:12\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1769\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1770\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1771\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         T: Deserialize<'de>,\n     \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SeqAccess::next_element`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `NaiveDate: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12218,"byte_end":12235,"line_start":405,"line_end":405,"column_start":10,"column_end":27,"is_primary":true,"text":[{"text":"    day: Option<NaiveDate>,","highlight_start":10,"highlight_end":27}],"label":"the trait `Deserialize<'_>` is not implemented for `NaiveDate`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `NaiveDate` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 140 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<NaiveDate>` to implement `Deserialize<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `NaiveDate: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:405:10\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m405\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     day: Option<NaiveDate>,\n     \u001b[1m\u001b[96m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `NaiveDate`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `NaiveDate` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a Path\n               &'a [u8]\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n             and 140 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<NaiveDate>` to implement `Deserialize<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_value`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs:1916:12\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1914\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1915\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1916\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         V: Deserialize<'de>,\n     \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `MapAccess::next_value`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `CustomShiftPaymentReoccurement: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12404,"byte_end":12442,"line_start":410,"line_end":410,"column_start":19,"column_end":57,"is_primary":true,"text":[{"text":"    reoccurement: Option<CustomShiftPaymentReoccurement>,","highlight_start":19,"highlight_end":57}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Deserialize<'_>` is not implemented for `CustomShiftPaymentReoccurement`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13477,"line_start":451,"line_end":451,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `CustomShiftPaymentReoccurement` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 140 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Deserialize<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `CustomShiftPaymentReoccurement: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:410:19\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     reoccurement: Option<CustomShiftPaymentReoccurement>,\n     \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Deserialize<'_>` is not implemented for `CustomShiftPaymentReoccurement`\n    \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:451:1\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m enum CustomShiftPaymentReoccurement {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `CustomShiftPaymentReoccurement` type\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a Path\n               &'a [u8]\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n             and 140 others\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Deserialize<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_value`\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_core-1.0.228\\src\\de\\mod.rs:1916:12\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1914\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[96m1915\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     where\n\u001b[1m\u001b[96m1916\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         V: Deserialize<'de>,\n     \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `MapAccess::next_value`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `NaiveDate: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11979,"byte_end":11990,"line_start":393,"line_end":393,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":21,"highlight_end":32}],"label":"the trait `Deserialize<'_>` is not implemented for `NaiveDate`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11979,"byte_end":11990,"line_start":393,"line_end":393,"column_start":21,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":21,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Deserialize)]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3397,"byte_end":3457,"line_start":122,"line_end":122,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"pub fn derive_deserialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `NaiveDate` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 140 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<NaiveDate>` to implement `Deserialize<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `_::_serde::__private228::de::missing_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs","byte_start":837,"byte_end":850,"line_start":24,"line_end":24,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs","byte_start":912,"byte_end":928,"line_start":26,"line_end":26,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    V: Deserialize<'de>,","highlight_start":8,"highlight_end":24}],"label":"required by this bound in `missing_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `NaiveDate: serde::Deserialize<'de>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:393:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `NaiveDate`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `NaiveDate` type\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n              &'a Path\n              &'a [u8]\n              &'a str\n              ()\n              (T,)\n              (T0, T1)\n              (T0, T1, T2)\n              (T0, T1, T2, T3)\n            and 140 others\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<NaiveDate>` to implement `Deserialize<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `_::_serde::__private228::de::missing_field`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs:26:8\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m24\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m-------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[1m\u001b[96m|\u001b[0m where\n \u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     V: Deserialize<'de>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `missing_field`\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `CustomShiftPaymentReoccurement: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":11979,"byte_end":11990,"line_start":393,"line_end":393,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":21,"highlight_end":32}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11979,"byte_end":11990,"line_start":393,"line_end":393,"column_start":21,"column_end":32,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":21,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Deserialize)]","def_site_span":{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde_derive-1.0.228\\src\\lib.rs","byte_start":3397,"byte_end":3457,"line_start":122,"line_end":122,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"pub fn derive_deserialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Deserialize<'_>` is not implemented for `CustomShiftPaymentReoccurement`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13477,"line_start":451,"line_end":451,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `CustomShiftPaymentReoccurement` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 140 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Deserialize<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `_::_serde::__private228::de::missing_field`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs","byte_start":837,"byte_end":850,"line_start":24,"line_end":24,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs","byte_start":912,"byte_end":928,"line_start":26,"line_end":26,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    V: Deserialize<'de>,","highlight_start":8,"highlight_end":24}],"label":"required by this bound in `missing_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `CustomShiftPaymentReoccurement: serde::Deserialize<'de>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:393:21\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Deserialize<'_>` is not implemented for `CustomShiftPaymentReoccurement`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:451:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m enum CustomShiftPaymentReoccurement {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `CustomShiftPaymentReoccurement` type\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n              &'a Path\n              &'a [u8]\n              &'a str\n              ()\n              (T,)\n              (T0, T1)\n              (T0, T1, T2)\n              (T0, T1, T2, T3)\n            and 140 others\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Deserialize<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `_::_serde::__private228::de::missing_field`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.228\\src\\private\\de.rs:26:8\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m24\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m-------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n \u001b[1m\u001b[96m25\u001b[0m \u001b[1m\u001b[96m|\u001b[0m where\n \u001b[1m\u001b[96m26\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     V: Deserialize<'de>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `missing_field`\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"`CustomShiftPaymentReoccurement` doesn't implement `Debug`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12390,"byte_end":12442,"line_start":410,"line_end":410,"column_start":5,"column_end":57,"is_primary":true,"text":[{"text":"    reoccurement: Option<CustomShiftPaymentReoccurement>,","highlight_start":5,"highlight_end":57}],"label":"the trait `Debug` is not implemented for `CustomShiftPaymentReoccurement`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11992,"byte_end":11997,"line_start":393,"line_end":393,"column_start":34,"column_end":39,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":34,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"C:\\Users\\justx\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\fmt\\mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"add `#[derive(Debug)]` to `CustomShiftPaymentReoccurement` or manually `impl Debug for CustomShiftPaymentReoccurement`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the trait `Debug` is implemented for `std::option::Option<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider annotating `CustomShiftPaymentReoccurement` with `#[derive(Debug)]`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13442,"line_start":451,"line_end":451,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: `CustomShiftPaymentReoccurement` doesn't implement `Debug`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:410:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     reoccurement: Option<CustomShiftPaymentReoccurement>,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Debug` is not implemented for `CustomShiftPaymentReoccurement`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: add `#[derive(Debug)]` to `CustomShiftPaymentReoccurement` or manually `impl Debug for CustomShiftPaymentReoccurement`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the trait `Debug` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mstd::option::Option<T>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `CustomShiftPaymentReoccurement` with `#[derive(Debug)]`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m451\u001b[0m \u001b[92m+ #[derive(Debug)]\u001b[0m\n\u001b[1m\u001b[96m452\u001b[0m \u001b[1m\u001b[96m| \u001b[0menum CustomShiftPaymentReoccurement {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `CustomShiftPaymentReoccurement: Clone` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12390,"byte_end":12442,"line_start":410,"line_end":410,"column_start":5,"column_end":57,"is_primary":true,"text":[{"text":"    reoccurement: Option<CustomShiftPaymentReoccurement>,","highlight_start":5,"highlight_end":57}],"label":"the trait `Clone` is not implemented for `CustomShiftPaymentReoccurement`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":11999,"byte_end":12004,"line_start":393,"line_end":393,"column_start":41,"column_end":46,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":41,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"C:\\Users\\justx\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub macro Clone($item:item) {","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider annotating `CustomShiftPaymentReoccurement` with `#[derive(Clone)]`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13442,"line_start":451,"line_end":451,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Clone)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `CustomShiftPaymentReoccurement: Clone` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:410:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n    \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     reoccurement: Option<CustomShiftPaymentReoccurement>,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Clone` is not implemented for `CustomShiftPaymentReoccurement`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `std::option::Option<CustomShiftPaymentReoccurement>` to implement `Clone`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `CustomShiftPaymentReoccurement` with `#[derive(Clone)]`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m451\u001b[0m \u001b[92m+ #[derive(Clone)]\u001b[0m\n\u001b[1m\u001b[96m452\u001b[0m \u001b[1m\u001b[96m| \u001b[0menum CustomShiftPaymentReoccurement {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"binary operation `==` cannot be applied to type `std::option::Option<CustomShiftPaymentReoccurement>`","code":{"code":"E0369","explanation":"A binary operation was attempted on a type which doesn't support it.\n\nErroneous code example:\n\n```compile_fail,E0369\nlet x = 12f32; // error: binary operation `<<` cannot be applied to\n               //        type `f32`\n\nx << 2;\n```\n\nTo fix this error, please check that this type implements this binary\noperation. Example:\n\n```\nlet x = 12u32; // the `u32` type does implement it:\n               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n\nx << 2; // ok!\n```\n\nIt is also possible to overload most operators for your own type by\nimplementing traits from `std::ops`.\n\nString concatenation appends the string on the right to the string on the\nleft and may require reallocation. This requires ownership of the string\non the left. If something should be added to a string literal, move the\nliteral to the heap by allocating it with `to_owned()` like in\n`\"Your text\".to_owned()`.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12390,"byte_end":12442,"line_start":410,"line_end":410,"column_start":5,"column_end":57,"is_primary":true,"text":[{"text":"    reoccurement: Option<CustomShiftPaymentReoccurement>,","highlight_start":5,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":12006,"byte_end":12015,"line_start":393,"line_end":393,"column_start":48,"column_end":57,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":48,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(PartialEq)]","def_site_span":{"file_name":"C:\\Users\\justx\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\cmp.rs","byte_start":10192,"byte_end":10211,"line_start":274,"line_end":274,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub macro PartialEq($item:item) {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"an implementation of `PartialEq` might be missing for `CustomShiftPaymentReoccurement`","code":null,"level":"note","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13477,"line_start":451,"line_end":451,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":36}],"label":"must implement `PartialEq`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider annotating `CustomShiftPaymentReoccurement` with `#[derive(PartialEq)]`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13442,"line_start":451,"line_end":451,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(PartialEq)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0369]\u001b[0m\u001b[1m\u001b[97m: binary operation `==` cannot be applied to type `std::option::Option<CustomShiftPaymentReoccurement>`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:410:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n    \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[96m---------\u001b[0m \u001b[1m\u001b[96min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     reoccurement: Option<CustomShiftPaymentReoccurement>,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: an implementation of `PartialEq` might be missing for `CustomShiftPaymentReoccurement`\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:451:1\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m enum CustomShiftPaymentReoccurement {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mmust implement `PartialEq`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `CustomShiftPaymentReoccurement` with `#[derive(PartialEq)]`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m451\u001b[0m \u001b[92m+ #[derive(PartialEq)]\u001b[0m\n\u001b[1m\u001b[96m452\u001b[0m \u001b[1m\u001b[96m| \u001b[0menum CustomShiftPaymentReoccurement {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`CustomShiftPaymentReoccurement` doesn't implement `Debug`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12390,"byte_end":12442,"line_start":410,"line_end":410,"column_start":5,"column_end":57,"is_primary":true,"text":[{"text":"    reoccurement: Option<CustomShiftPaymentReoccurement>,","highlight_start":5,"highlight_end":57}],"label":"the trait `Debug` is not implemented for `CustomShiftPaymentReoccurement`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\main.rs","byte_start":12017,"byte_end":12022,"line_start":393,"line_end":393,"column_start":59,"column_end":64,"is_primary":false,"text":[{"text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]","highlight_start":59,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"C:\\Users\\justx\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\fmt\\mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"add `#[derive(Debug)]` to `CustomShiftPaymentReoccurement` or manually `impl Debug for CustomShiftPaymentReoccurement`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the trait `Debug` is implemented for `std::option::Option<T>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider annotating `CustomShiftPaymentReoccurement` with `#[derive(Debug)]`","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":13442,"byte_end":13442,"line_start":451,"line_end":451,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"enum CustomShiftPaymentReoccurement {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Debug)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: `CustomShiftPaymentReoccurement` doesn't implement `Debug`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:410:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m393\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Debug)]\n    \u001b[1m\u001b[96m|\u001b[0m                                                           \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     reoccurement: Option<CustomShiftPaymentReoccurement>,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Debug` is not implemented for `CustomShiftPaymentReoccurement`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: add `#[derive(Debug)]` to `CustomShiftPaymentReoccurement` or manually `impl Debug for CustomShiftPaymentReoccurement`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the trait `Debug` \u001b[1m\u001b[35mis\u001b[0m implemented for `\u001b[1m\u001b[35mstd::option::Option<T>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `CustomShiftPaymentReoccurement` with `#[derive(Debug)]`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m451\u001b[0m \u001b[92m+ #[derive(Debug)]\u001b[0m\n\u001b[1m\u001b[96m452\u001b[0m \u001b[1m\u001b[96m| \u001b[0menum CustomShiftPaymentReoccurement {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&str: ToKeyDefinition<KeyOptions>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13014,"byte_end":13022,"line_start":431,"line_end":431,"column_start":73,"column_end":81,"is_primary":true,"text":[{"text":"        let payments = r_txn.scan().secondary::<CustomShiftPaymentType>(\"job_id\")?","highlight_start":73,"highlight_end":81}],"label":"the trait `ToKeyDefinition<KeyOptions>` is not implemented for `&str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":12978,"byte_end":12987,"line_start":431,"line_end":431,"column_start":37,"column_end":46,"is_primary":false,"text":[{"text":"        let payments = r_txn.scan().secondary::<CustomShiftPaymentType>(\"job_id\")?","highlight_start":37,"highlight_end":46}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `ToKeyDefinition<O>`:\n  `CustomShiftPaymentTypeKey` implements `ToKeyDefinition<KeyOptions>`\n  `KeyDefinition<O>` implements `ToKeyDefinition<O>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `RScan::<'_, 'txn>::secondary`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\transaction\\query\\scan\\mod.rs","byte_start":1643,"byte_end":1652,"line_start":37,"line_end":37,"column_start":12,"column_end":21,"is_primary":false,"text":[{"text":"    pub fn secondary<T: ToInput>(","highlight_start":12,"highlight_end":21}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\transaction\\query\\scan\\mod.rs","byte_start":1703,"byte_end":1730,"line_start":39,"line_end":39,"column_start":23,"column_end":50,"is_primary":true,"text":[{"text":"        key_def: impl ToKeyDefinition<KeyOptions>,","highlight_start":23,"highlight_end":50}],"label":"required by this bound in `RScan::<'_, 'txn>::secondary`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&str: ToKeyDefinition<KeyOptions>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:431:73\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m431\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let payments = r_txn.scan().secondary::<CustomShiftPaymentType>(\"job_id\")?\n    \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[96m---------\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `ToKeyDefinition<KeyOptions>` is not implemented for `&str`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                                     \u001b[1m\u001b[96mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `ToKeyDefinition<O>`:\n              `CustomShiftPaymentTypeKey` implements `ToKeyDefinition<KeyOptions>`\n              `KeyDefinition<O>` implements `ToKeyDefinition<O>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `RScan::<'_, 'txn>::secondary`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\justx\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\native_db-0.8.2\\src\\transaction\\query\\scan\\mod.rs:39:23\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m37\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn secondary<T: ToInput>(\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[96m---------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this associated function\u001b[0m\n \u001b[1m\u001b[96m38\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         &self,\n \u001b[1m\u001b[96m39\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         key_def: impl ToKeyDefinition<KeyOptions>,\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `RScan::<'_, 'txn>::secondary`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `is` found for struct `SecondaryScan<PrimaryTable, SecondaryTable, T>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":12965,"byte_end":13034,"line_start":431,"line_end":432,"column_start":24,"column_end":10,"is_primary":false,"text":[{"text":"        let payments = r_txn.scan().secondary::<CustomShiftPaymentType>(\"job_id\")?","highlight_start":24,"highlight_end":83},{"text":"        .is(target_job_id)?","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":13034,"byte_end":13036,"line_start":432,"line_end":432,"column_start":10,"column_end":12,"is_primary":true,"text":[{"text":"        .is(target_job_id)?","highlight_start":10,"highlight_end":12}],"label":"method not found in `SecondaryScan<ReadOnlyTable<Key, &[u8]>, ..., ...>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the full name for the type has been written to 'C:\\Users\\justx\\Documents\\Visual Studio Projects\\learning_rust\\wage_calculator\\target\\debug\\deps\\wage_calculator-5e11087c780f4b57.long-type-4320080053902256584.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `is` found for struct `SecondaryScan<PrimaryTable, SecondaryTable, T>` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:432:10\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m431\u001b[0m \u001b[1m\u001b[96m|\u001b[0m           let payments = r_txn.scan().secondary::<CustomShiftPaymentType>(\"job_id\")?\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m ________________________-\u001b[0m\n\u001b[1m\u001b[96m432\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         .is(target_job_id)?\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m-\u001b[0m\u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `SecondaryScan<ReadOnlyTable<Key, &[u8]>, ..., ...>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|_________|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: the full name for the type has been written to 'C:\\Users\\justx\\Documents\\Visual Studio Projects\\learning_rust\\wage_calculator\\target\\debug\\deps\\wage_calculator-5e11087c780f4b57.long-type-4320080053902256584.txt'\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"missing field `reoccurement` in initializer of `CustomShiftPaymentType`","code":{"code":"E0063","explanation":"A struct's or struct-like enum variant's field was not provided.\n\nErroneous code example:\n\n```compile_fail,E0063\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\nEach field should be specified exactly once. Example:\n\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13277,"byte_end":13299,"line_start":445,"line_end":445,"column_start":17,"column_end":39,"is_primary":true,"text":[{"text":"        let _ = CustomShiftPaymentType { id: 1, shift_id: 1, job_id: 1, name: format!(\"\"), day: None, is_taxable: None, multiplier: None, amount: None };","highlight_start":17,"highlight_end":39}],"label":"missing `reoccurement`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0063]\u001b[0m\u001b[1m\u001b[97m: missing field `reoccurement` in initializer of `CustomShiftPaymentType`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:445:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m445\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m   let _ = CustomShiftPaymentType { id: 1, shift_id: 1, job_id: 1, name: format!(\"\"), day: None, is_taxable: None, multiplier: None, a\u001b[1m\u001b[96m...\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmissing `reoccurement`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"missing fields `id`, `job_id` and `shift_id` in initializer of `ShiftPayment`","code":{"code":"E0063","explanation":"A struct's or struct-like enum variant's field was not provided.\n\nErroneous code example:\n\n```compile_fail,E0063\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\nEach field should be specified exactly once. Example:\n\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":13926,"byte_end":13938,"line_start":477,"line_end":477,"column_start":25,"column_end":37,"is_primary":true,"text":[{"text":"        let shift_pay = ShiftPayment {","highlight_start":25,"highlight_end":37}],"label":"missing `id`, `job_id` and `shift_id`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0063]\u001b[0m\u001b[1m\u001b[97m: missing fields `id`, `job_id` and `shift_id` in initializer of `ShiftPayment`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:477:25\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m477\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let shift_pay = ShiftPayment {\n    \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmissing `id`, `job_id` and `shift_id`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"missing fields `id`, `job_id` and `shift_id` in initializer of `ShiftPayment`","code":{"code":"E0063","explanation":"A struct's or struct-like enum variant's field was not provided.\n\nErroneous code example:\n\n```compile_fail,E0063\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\nEach field should be specified exactly once. Example:\n\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":14171,"byte_end":14183,"line_start":490,"line_end":490,"column_start":9,"column_end":21,"is_primary":true,"text":[{"text":"        ShiftPayment {","highlight_start":9,"highlight_end":21}],"label":"missing `id`, `job_id` and `shift_id`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0063]\u001b[0m\u001b[1m\u001b[97m: missing fields `id`, `job_id` and `shift_id` in initializer of `ShiftPayment`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:490:9\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m490\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         ShiftPayment {\n    \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmissing `id`, `job_id` and `shift_id`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `target_date`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":233,"byte_end":244,"line_start":9,"line_end":9,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let target_date = ","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":233,"byte_end":244,"line_start":9,"line_end":9,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let target_date = ","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":"_target_date","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `target_date`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:9:9\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let target_date = \n  \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_target_date`\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `first_day`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":342,"byte_end":351,"line_start":14,"line_end":14,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"    let first_day = NaiveDate::from_ymd_opt(2026, 1, 15).expect(\"Invalid date\");","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":342,"byte_end":351,"line_start":14,"line_end":14,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"    let first_day = NaiveDate::from_ymd_opt(2026, 1, 15).expect(\"Invalid date\");","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":"_first_day","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `first_day`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:14:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m14\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let first_day = NaiveDate::from_ymd_opt(2026, 1, 15).expect(\"Invalid date\");\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_first_day`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `start_date`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":3476,"byte_end":3486,"line_start":110,"line_end":110,"column_start":41,"column_end":51,"is_primary":true,"text":[{"text":"    fn get_shifts_for_period_of(&self,  start_date: NaiveDate, end_date: NaiveDate) -> Vec<Shift> {","highlight_start":41,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":3476,"byte_end":3486,"line_start":110,"line_end":110,"column_start":41,"column_end":51,"is_primary":true,"text":[{"text":"    fn get_shifts_for_period_of(&self,  start_date: NaiveDate, end_date: NaiveDate) -> Vec<Shift> {","highlight_start":41,"highlight_end":51}],"label":null,"suggested_replacement":"_start_date","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `start_date`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:110:41\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m110\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn get_shifts_for_period_of(&self,  start_date: NaiveDate, end_date: NaiveDate) -> Vec<Shift> {\n    \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_start_date`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `end_date`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":3499,"byte_end":3507,"line_start":110,"line_end":110,"column_start":64,"column_end":72,"is_primary":true,"text":[{"text":"    fn get_shifts_for_period_of(&self,  start_date: NaiveDate, end_date: NaiveDate) -> Vec<Shift> {","highlight_start":64,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":3499,"byte_end":3507,"line_start":110,"line_end":110,"column_start":64,"column_end":72,"is_primary":true,"text":[{"text":"    fn get_shifts_for_period_of(&self,  start_date: NaiveDate, end_date: NaiveDate) -> Vec<Shift> {","highlight_start":64,"highlight_end":72}],"label":null,"suggested_replacement":"_end_date","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `end_date`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:110:64\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m110\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn get_shifts_for_period_of(&self,  start_date: NaiveDate, end_date: NaiveDate) -> Vec<Shift> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                                \u001b[1m\u001b[93m^^^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_end_date`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `shifts`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":3548,"byte_end":3554,"line_start":111,"line_end":111,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"        let shifts: Vec<Shift> = Vec::new();","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":3548,"byte_end":3554,"line_start":111,"line_end":111,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"        let shifts: Vec<Shift> = Vec::new();","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":"_shifts","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused variable: `shifts`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\main.rs:111:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m111\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let shifts: Vec<Shift> = Vec::new();\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[93m^^^^^^\u001b[0m \u001b[1m\u001b[93mhelp: if this is intentional, prefix it with an underscore: `_shifts`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 25 previous errors; 6 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 25 previous errors; 6 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0063, E0119, E0277, E0369, E0412, E0425, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0063, E0119, E0277, E0369, E0412, E0425, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0063`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0063`.\u001b[0m\n"}
